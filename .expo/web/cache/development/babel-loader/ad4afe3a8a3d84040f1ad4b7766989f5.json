{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as helpers from \"./helpers\";\nexport default function createCompatNavigationProp(navigation, state, context, _isFirstRouteInParent) {\n  var _state$params;\n\n  context.parent = context.parent || {};\n  context.subscriptions = context.subscriptions || {\n    didFocus: new Map(),\n    didBlur: new Map(),\n    refocus: new Map()\n  };\n  return _objectSpread(_objectSpread(_objectSpread({}, navigation), Object.entries(helpers).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        method = _ref2[1];\n\n    if (name in navigation) {\n      acc[name] = function () {\n        return navigation.dispatch(method.apply(void 0, arguments));\n      };\n    }\n\n    return acc;\n  }, {})), {}, {\n    original: navigation,\n    addListener: function addListener(type, callback) {\n      var unsubscribe;\n\n      switch (type) {\n        case 'willFocus':\n          unsubscribe = navigation.addListener('focus', callback);\n          break;\n\n        case 'willBlur':\n          unsubscribe = navigation.addListener('blur', callback);\n          break;\n\n        case 'didFocus':\n          {\n            var listener = function listener() {\n              if (navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('transitionEnd', listener);\n            context.subscriptions.didFocus.set(callback, unsubscribe);\n            break;\n          }\n\n        case 'didBlur':\n          {\n            var _listener = function _listener() {\n              if (!navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('transitionEnd', _listener);\n            context.subscriptions.didBlur.set(callback, unsubscribe);\n            break;\n          }\n\n        case 'refocus':\n          {\n            var _listener2 = function _listener2() {\n              if (navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('tabPress', _listener2);\n            context.subscriptions.refocus.set(callback, unsubscribe);\n            break;\n          }\n\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n\n        default:\n          unsubscribe = navigation.addListener(type, callback);\n      }\n\n      var subscription = function subscription() {\n        return unsubscribe();\n      };\n\n      subscription.remove = unsubscribe;\n      return subscription;\n    },\n    removeListener: function removeListener(type, callback) {\n      context.subscriptions = context.subscriptions || {};\n\n      switch (type) {\n        case 'willFocus':\n          navigation.removeListener('focus', callback);\n          break;\n\n        case 'willBlur':\n          navigation.removeListener('blur', callback);\n          break;\n\n        case 'didFocus':\n          {\n            var unsubscribe = context.subscriptions.didFocus.get(callback);\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            break;\n          }\n\n        case 'didBlur':\n          {\n            var _unsubscribe = context.subscriptions.didBlur.get(callback);\n\n            _unsubscribe === null || _unsubscribe === void 0 ? void 0 : _unsubscribe();\n            break;\n          }\n\n        case 'refocus':\n          {\n            var _unsubscribe2 = context.subscriptions.refocus.get(callback);\n\n            _unsubscribe2 === null || _unsubscribe2 === void 0 ? void 0 : _unsubscribe2();\n            break;\n          }\n\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n\n        default:\n          navigation.removeListener(type, callback);\n      }\n    },\n    state: {\n      key: state.key,\n      routeName: state.name,\n      params: (_state$params = state.params) !== null && _state$params !== void 0 ? _state$params : {},\n\n      get index() {\n        var _state$state;\n\n        if (state.index !== undefined) {\n          return state.index;\n        }\n\n        console.warn(\"Looks like you are using 'navigation.state.index' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'index' property in the child navigation state.\");\n        return (_state$state = state.state) === null || _state$state === void 0 ? void 0 : _state$state.index;\n      },\n\n      get routes() {\n        var _state$state2;\n\n        if (state.routes !== undefined) {\n          return state.routes;\n        }\n\n        console.warn(\"Looks like you are using 'navigation.state.routes' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'routes' property in the child navigation state.\");\n        return (_state$state2 = state.state) === null || _state$state2 === void 0 ? void 0 : _state$state2.routes;\n      }\n\n    },\n    getParam: function getParam(paramName, defaultValue) {\n      var params = state.params;\n\n      if (params && paramName in params) {\n        return params[paramName];\n      }\n\n      return defaultValue;\n    },\n    isFirstRouteInParent: function isFirstRouteInParent() {\n      if (typeof _isFirstRouteInParent === 'boolean') {\n        return _isFirstRouteInParent;\n      }\n\n      var _navigation$dangerous = navigation.dangerouslyGetState(),\n          routes = _navigation$dangerous.routes;\n\n      return routes[0].key === state.key;\n    },\n    dangerouslyGetParent: function dangerouslyGetParent() {\n      var parent = navigation.dangerouslyGetParent();\n\n      if (parent) {\n        return createCompatNavigationProp(parent, navigation.dangerouslyGetState(), context.parent);\n      }\n\n      return undefined;\n    }\n  });\n}","map":{"version":3,"sources":["createCompatNavigationProp.tsx"],"names":["context","didFocus","didBlur","refocus","name","acc","navigation","method","original","addListener","unsubscribe","listener","callback","subscription","removeListener","state","key","routeName","params","console","getParam","paramName","isFirstRouteInParent","routes","dangerouslyGetParent","parent","createCompatNavigationProp"],"mappings":"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","sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  ParamListBase,\n  NavigationProp,\n  RouteProp,\n} from '@react-navigation/native';\nimport * as helpers from './helpers';\nimport type { CompatNavigationProp } from './types';\n\ntype EventName =\n  | 'action'\n  | 'willFocus'\n  | 'willBlur'\n  | 'didFocus'\n  | 'didBlur'\n  | 'refocus';\n\nexport default function createCompatNavigationProp<\n  NavigationPropType extends NavigationProp<ParamListBase>,\n  ParamList extends ParamListBase = NavigationPropType extends NavigationProp<\n    infer P,\n    any,\n    any,\n    any,\n    any\n  >\n    ? P\n    : ParamListBase\n>(\n  navigation: NavigationPropType,\n  state:\n    | (RouteProp<ParamList, keyof ParamList> & {\n        state?: NavigationState | PartialState<NavigationState>;\n      })\n    | NavigationState\n    | PartialState<NavigationState>,\n  context: Record<string, any>,\n  isFirstRouteInParent?: boolean\n): CompatNavigationProp<NavigationPropType> {\n  context.parent = context.parent || {};\n  context.subscriptions = context.subscriptions || {\n    didFocus: new Map<() => void, () => void>(),\n    didBlur: new Map<() => void, () => void>(),\n    refocus: new Map<() => void, () => void>(),\n  };\n\n  return {\n    ...navigation,\n    ...Object.entries(helpers).reduce<{\n      [key: string]: (...args: any[]) => void;\n    }>((acc, [name, method]: [string, Function]) => {\n      if (name in navigation) {\n        acc[name] = (...args: any[]) => navigation.dispatch(method(...args));\n      }\n\n      return acc;\n    }, {}),\n    original: navigation,\n    addListener(type: EventName, callback: () => void) {\n      let unsubscribe: () => void;\n\n      switch (type) {\n        case 'willFocus':\n          unsubscribe = navigation.addListener('focus', callback);\n          break;\n        case 'willBlur':\n          unsubscribe = navigation.addListener('blur', callback);\n          break;\n        case 'didFocus': {\n          const listener = () => {\n            if (navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('transitionEnd', listener);\n          context.subscriptions.didFocus.set(callback, unsubscribe);\n          break;\n        }\n        case 'didBlur': {\n          const listener = () => {\n            if (!navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('transitionEnd', listener);\n          context.subscriptions.didBlur.set(callback, unsubscribe);\n          break;\n        }\n        case 'refocus': {\n          const listener = () => {\n            if (navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('tabPress', listener);\n          context.subscriptions.refocus.set(callback, unsubscribe);\n          break;\n        }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          unsubscribe = navigation.addListener(type, callback);\n      }\n\n      const subscription = () => unsubscribe();\n\n      subscription.remove = unsubscribe;\n\n      return subscription;\n    },\n    removeListener(type: EventName, callback: () => void) {\n      context.subscriptions = context.subscriptions || {};\n\n      switch (type) {\n        case 'willFocus':\n          navigation.removeListener('focus', callback);\n          break;\n        case 'willBlur':\n          navigation.removeListener('blur', callback);\n          break;\n        case 'didFocus': {\n          const unsubscribe = context.subscriptions.didFocus.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'didBlur': {\n          const unsubscribe = context.subscriptions.didBlur.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'refocus': {\n          const unsubscribe = context.subscriptions.refocus.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          navigation.removeListener(type, callback);\n      }\n    },\n    state: {\n      key: state.key,\n      // @ts-expect-error\n      routeName: state.name,\n      // @ts-expect-error\n      params: state.params ?? {},\n      get index() {\n        // @ts-expect-error\n        if (state.index !== undefined) {\n          // @ts-expect-error\n          return state.index;\n        }\n\n        console.warn(\n          \"Looks like you are using 'navigation.state.index' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'index' property in the child navigation state.\"\n        );\n\n        // @ts-expect-error\n        return state.state?.index;\n      },\n      get routes() {\n        // @ts-expect-error\n        if (state.routes !== undefined) {\n          // @ts-expect-error\n          return state.routes;\n        }\n\n        console.warn(\n          \"Looks like you are using 'navigation.state.routes' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'routes' property in the child navigation state.\"\n        );\n\n        // @ts-expect-error\n        return state.state?.routes;\n      },\n    },\n    getParam<T extends keyof ParamList>(\n      paramName: T,\n      defaultValue: ParamList[T]\n    ): ParamList[T] {\n      // @ts-expect-error\n      const params = state.params;\n\n      if (params && paramName in params) {\n        return params[paramName];\n      }\n\n      return defaultValue;\n    },\n    isFirstRouteInParent(): boolean {\n      if (typeof isFirstRouteInParent === 'boolean') {\n        return isFirstRouteInParent;\n      }\n\n      const { routes } = navigation.dangerouslyGetState();\n\n      return routes[0].key === state.key;\n    },\n    dangerouslyGetParent() {\n      const parent = navigation.dangerouslyGetParent();\n\n      if (parent) {\n        return createCompatNavigationProp(\n          parent,\n          navigation.dangerouslyGetState(),\n          context.parent\n        );\n      }\n\n      return undefined;\n    },\n  } as any;\n}\n"]},"metadata":{},"sourceType":"module"}